         * this->verify return les scopes requested sous formes d'array après avoir vérifier
         * le client est autorisé à demander ses scopes
         *
         * la method handle permet de modifier les scopes autorisés par l'utilisateur en dernier parametre
         *
         * Avant l'authorization, l'implementation permet avec verify de recupérer des scopes autorisés pour un client
         * par défaut ou une liste de scope global par défaut et de les proposer à l'utilisateur pour cocher/decocher
         *
         * s'il ne peut pas modifier le scope requis, alors le parametre vaut null et handle() utilise le scope de la requete
         * c'est à verify() de s'assurer que les scopes requis par le client sont autorisés pour ce dernier
         * ClientInterface.isScopeAllowed() : bool
         * Config : predefined scope value si le scope n'est pas dans la request ou fail
         *
         * The authorization server SHOULD take the client identity
         * into account when choosing how to honor the requested scope and MAY
         * issue an access token with less rights than requested.
         *
         * Dans verify :
         * ScopePolicy(requestedScope, client) : errorResponse exception|allowedScopes
         * si requestedScope = '' : error ou config->getDefaultScopes() puis verify inclu dans client->getGrantedScopes() 1*
         * sinon verify requestedScope inclu dans client->getGrantedScopes()
         *
         * 1* : s'assurer que les scopes configuré par défault sont autorisés pour le client, error sinon
         *
         * ensuite allowedScopes est soumis/ou non au resourceOwner
         *
         * public function scopeExists($scope)
         * {
         * $scope = explode(' ', trim($scope));
         * return (count(array_diff($scope, $this->supportedScopes)) == 0);
         * }
         *
         * public function checkScope($required_scope, $available_scope)
         * {
         * $required_scope = explode(' ', trim($required_scope));
         * $available_scope = explode(' ', trim($available_scope));
         * return (count(array_diff($required_scope, $available_scope)) == 0);
         * }
         *
         * Dans le cas d'un role admin, none_policy est utilisé et le role est ajouté par le resource provider en fonction du client
         * associé au token (first party par exemple), si le client est un first_party
         * alors les roles = scopes + roles de l'user, sinon roles = scope
         */
//        if(!$authorizationRequest->getScope()) {
//            $scope = $client->defaultScopes();
//        }